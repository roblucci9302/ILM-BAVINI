'use client';

import { memo, useEffect, useRef, useState } from 'react';
import { classNames } from '~/utils/classNames';
import { createScopedLogger } from '~/utils/logger';
import { highlightCode, isSupportedLanguage, type SupportedTheme } from '~/lib/shiki';
import { useShikiWorker } from '~/lib/hooks/useShikiWorker';

import styles from './CodeBlock.module.scss';

const logger = createScopedLogger('CodeBlock');

/** Debounce delay for syntax highlighting during streaming (ms) */
const HIGHLIGHT_DEBOUNCE_MS = 150;

/** Duration to show "copied" feedback before resetting (ms) */
const COPY_FEEDBACK_DURATION_MS = 2000;

/**
 * Seuil pour utiliser le worker (en caractères).
 * Les petits blocs sont plus rapides sur le main thread.
 */
const WORKER_THRESHOLD = 2000;

interface CodeBlockProps {
  className?: string;
  code: string;
  language?: string;
  theme?: SupportedTheme;
  disableCopy?: boolean;

  /** Forcer l'utilisation du worker même pour les petits blocs */
  forceWorker?: boolean;
}

export const CodeBlock = memo(
  ({
    className,
    code,
    language = 'plaintext',
    theme = 'dark-plus',
    disableCopy = false,
    forceWorker = false,
  }: CodeBlockProps) => {
    const [html, setHTML] = useState<string | undefined>(undefined);
    const [copied, setCopied] = useState(false);
    const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
    const lastCodeRef = useRef<string>('');

    // Worker pour les gros blocs de code
    const { highlight: workerHighlight, isReady: workerReady } = useShikiWorker();

    // Déterminer si on utilise le worker
    const useWorker = (forceWorker || code.length > WORKER_THRESHOLD) && workerReady;

    const copyToClipboard = () => {
      if (copied) {
        return;
      }

      navigator.clipboard.writeText(code);

      setCopied(true);

      setTimeout(() => {
        setCopied(false);
      }, COPY_FEEDBACK_DURATION_MS);
    };

    useEffect(() => {
      // Warn about unsupported languages (will fallback to plaintext)
      if (language && language !== 'plaintext' && !isSupportedLanguage(language)) {
        logger.warn(`Language '${language}' not in optimized set, using plaintext`);
      }

      // Clear any pending debounce
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
      }

      // Skip if code hasn't changed (prevents duplicate processing)
      if (code === lastCodeRef.current) {
        return;
      }

      const processCode = async () => {
        logger.trace(`Highlighting ${code.length} chars, lang=${language}, worker=${useWorker}`);
        lastCodeRef.current = code;

        try {
          let highlighted: string;

          if (useWorker) {
            // Utiliser le worker pour les gros blocs (libère le main thread)
            highlighted = await workerHighlight(code, language, theme);
          } else {
            // Utiliser le main thread pour les petits blocs (moins d'overhead)
            highlighted = await highlightCode(code, language, theme);
          }

          setHTML(highlighted);
        } catch (error) {
          // Fallback au main thread si le worker échoue
          logger.warn('Worker highlighting failed, falling back to main thread', error);

          const highlighted = await highlightCode(code, language, theme);
          setHTML(highlighted);
        }
      };

      // Debounce syntax highlighting to reduce CPU during streaming
      debounceRef.current = setTimeout(processCode, HIGHLIGHT_DEBOUNCE_MS);

      return () => {
        if (debounceRef.current) {
          clearTimeout(debounceRef.current);
        }
      };
    }, [code, language, theme, useWorker, workerHighlight]);

    return (
      <div className={classNames('relative group text-left', className)}>
        <div
          className={classNames(
            styles.CopyButtonContainer,
            'bg-white absolute top-[10px] right-[10px] rounded-md z-10 text-lg flex items-center justify-center opacity-0 group-hover:opacity-100',
            {
              'rounded-l-0 opacity-100': copied,
            },
          )}
        >
          {!disableCopy && (
            <button
              className={classNames(
                'flex items-center bg-transparent p-[6px] justify-center before:bg-white before:rounded-l-md before:text-gray-500 before:border-r before:border-gray-300',
                {
                  'before:opacity-0': !copied,
                  'before:opacity-100': copied,
                },
              )}
              title="Copier le code"
              onClick={() => copyToClipboard()}
            >
              <div className="i-ph:clipboard-text-duotone"></div>
            </button>
          )}
        </div>
        {/* safe: html is generated by Shiki codeToHtml which escapes all HTML entities */}
        <div dangerouslySetInnerHTML={{ __html: html ?? '' }}></div>
      </div>
    );
  },
);
